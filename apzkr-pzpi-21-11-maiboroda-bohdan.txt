Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для контролю рівня алкоголю в крові працівників на робочому місці.

Студент гр. ПЗПІ-21-11	__________________ Майборода Б. О.
(підпис)
Керівник роботи	__________________ доц. Лещинська І.О.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
 Комісія:	__________________ доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)



Харків 2024 р.
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6				____        
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Майбороді Богдану Олександровичу
1.	Тема роботи: «Програмна система для контролю рівня алкоголю в крові працівників на робочому місці»                                                                         
2.	Термін узгодження завдання курсової роботи « 1 »  квітня  2024 р.
3.	Термін здачі студентом закінченої роботи « 10 » червня  2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити:
унікальність, можливість заробітку, актуальність, розповсюдженість, масштабованість, пітримка інтернаціоналізації, локалізація, забезпечення конфіденційності та адміністрування системи, реалізація чотирьох компонентів (Back-end, Front-end, Mobile app, IoT)	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, розробка програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) Deployment Diagram, Use Case Diagram, Entity-Relationship Model, Interaction Overview Diagram,  Activity Diagram, State Diagram, Component Diagram, Package Diagram	


КАЛЕНДАРНИЙ ПЛАН


№	Основні етапи виконання проєкту
в рамках лабораторних робіт	Термін виконання
етапів	Примітка
1	Vision & Scope	01.04.24	
2	Розроблення серверної частини	22.04.24	
3	Розробка IoT частини	13.05.24	
4	Розробка клієнтської частини	27.05.24	
5	Розробка мобільного застосунку	10.06.24	

Дата видачі теми проєкту: «1»  квітня  2024 р.


	Викладач лабораторних робіт                         ст. викл. Сокорчук І. П.
        (підпис)


Завдання прийняв до виконання
ст.гр. ПЗПІІ-21-11	                      	      Майборода Б. О


РЕФЕРАТ


Пояснювальна записка до курсової роботи: 100 с., 23 рис., 2 табл., 3 додатки,  4 джерела. 
АДМІНІСТРАТОР, ВИМІРЮВАННЯ, КОМПАНІЯ, КЛІЄНТ, КОНТРОЛЬ ДОСТУПУ, ЛОКАЦІЯ, ПРОГРАМНА СИСТЕМА, СПОВІЩЕННЯ.

Курсова робота спрямована на створення комплексної програмної системи для контролю рівня алкоголю в крові працівників під час їхньої роботи. Основною метою проекту є забезпечення безпеки та підвищення ефективності виробничих процесів шляхом розробки інтегрованої системи, яка дозволяє відслідковувати та контролювати рівень алкоголю у працівників.
Система базується на мові програмування Golang для серверної частини, що забезпечує стабільність і безпеку обробки даних. Веб-інтерфейс програми розробляється з використанням Vue.js для зручного користування та відображення результатів моніторингу.
Для збору даних про рівень алкоголю було створено IoT програму написану на мові програмування С++, що дозволило проводити тести у реальному часі. Це дозволяє точно визначати стан працівників та надавати оперативні повідомлення адміністрації у разі виявлення сп'яніння.
Додатково, програмна система передбачає зберігання даних тестування для виявлення тенденцій та покращення стратегій контролю. Це дозволяє оптимізувати процеси управління та реагування на можливі небезпечні ситуації.
Результатом роботи буде створено функціональну програмну систему, яка не лише забезпечить безпеку на робочому місці, а й дозволить підприємствам підвищити ефективність та знизити ризики, пов'язані з недопустимим вживанням алкоголю під час роботи


ЗМІСТ


Вступ	7
1 Аналіз предметної області	8
1.1 Бізнес-вимоги	8
1.1.1 Бізнес-можливості	8
1.1.2 Бізнес цілі та критерії успіху	9
1.1.3 Потреби клієнтів або ринку	10
1.1.4 Бізнес-ризики	11
1.2 Концепція рішення	12
1.2.1 Окреслення концепції	12
1.2.2 Головна функціональність	13
1.2.3 Припущення і залежності	15
1.3 Рамки та обмеження проєкту	16
1.3.1 Рамки первинного випуску	16
1.3.2 Рамки наступних випусків	18
1.3.3 Обмеження та вийнятки	20
1.4 Бізнес-контекст	21
1.4.1 Профілі зацікавлених сторін	21
1.4.2 Пріоритети проєкту	23
1.4.3 Робоче середовище	24
2 постановка задачі	26
3 проєктування бази даних	27
3.1 Побудова ER-діаграми	27
3.2 Побудова логічної моделі бази даних на основі ER-діаграми	28
4 Архітектура програмної системи	32
4.1 Архітектура серверної частини	32
4.2 Архітектура IoT частини	35
4.3 Архітектура клієнтської частини	40
5 Опис програмної системи	44
5.1 Виклик і завантаження	44
5.2 Призначення і логічна структура	45
5.3 Опис програмної реалізації	46
Висновок	52
Перелік джерел посилання	53
Додаток А Програмний код серверної частини	54
А.1 Код основного файлу для роботи сервера main.go	54
А.2 Код адміністрації програмної системи admin_mysql.go	55
А.3 Програмний код з функціями пов’язаними з вимірюванням алкоголю в крові	67
А.4 Програмний код панелі адміністратора	72
Додаток Б Програмний код IoT частини	84
Додаток В Програмний код клієнтської частини	90
В.1 Програмний код комунікації з серверною частиною	90
В.2 Програмний код шляхів клієнтської частини router.js	95
Додаток Г Результат перевірки на плагіат	101
Додаток Ґ Посилання на відеозапис тестування системи	102


ВСТУП


На сьогодні, безпека на робочому місці та ефективне виробництво стають все більшою проблемою для різних галузей промисловості. Одним із серйозних аспектів, що впливає на цю сферу, є контроль за вживанням алкоголю працівниками під час робочого часу. Сп'яніння на робочому місці може призвести до небезпечних ситуацій, аварій, травм та збитків як для працівників, так і для підприємства загалом. 
Саме тому стає актуальною розробка програмної системи, яка забезпечить постійний моніторинг рівня алкоголю в крові працівників на робочому місці. Така система має на меті попередження небезпечних ситуацій та збереження безпеки на роботі. Завдяки цій системі, роботодавці зможуть ефективно контролювати вживання алкоголю серед свого персоналу та приймати вчасні заходи у разі виявлення сп'яніння. 
Головною метою програмного продукту є забезпечення безпеки та здоров'я працівників на робочому місці. Це дозволить підприємствам зменшити ризик аварій, збитків та травм, а також підвищити продуктивність праці та загальну ефективність виробничих процесів. 
Узагальнюючи, програмна система для контролю рівня алкоголю в крові працівників на робочому місці є необхідною складовою для забезпечення безпеки та ефективності в робочому середовищі. Вона сприятиме підвищенню стандартів безпеки та забезпеченню якісної та безпечної працівникам обстановки на роботі.


1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес-можливості


Серед аналогів програмної системи для контролю рівня алкоголю в крові працівників на робочому місці можна виділити два основних конкуренти: "AlcoCheck" та "AlcoGuard". 
"AlcoCheck" - це програмне забезпечення, спеціалізоване на контролі рівня алкоголю в крові працівників на робочому місці. Система дозволяє підприємствам ефективно вести моніторинг та контроль за алкогольними показниками своїх працівників, що дозволяє підвищити безпеку та продуктивність на робочому місці. 
Переваги: 
-	широкий функціонал, що охоплює всі аспекти контролю за рівнем алкоголю в крові; 
-	висока надійність та безпека даних;
-	можливість інтеграції з іншими системами безпеки на робочому місці. 
Недоліки: 
-	залежність від наявності Інтернет-з'єднання для доступу до системи; 
-	потреба в спеціалізованому обладнанні для вимірювання рівня алкоголю в крові. 
"AlcoGuard" - це інша програмна система, спрямована на контроль рівня алкоголю в крові на робочому місці. Вона надає комплексний підхід до моніторингу та контролю за алкогольними показниками працівників, забезпечуючи безпеку та ефективність виробничого процесу. 

Переваги: 
-	кросплатформеність, що дозволяє користувачам доступатися до системи з будь-якого пристрою; 
-	інтеграція з іншими системами управління безпекою та виробничим процесом; 
-	можливість аналізу та збереження даних для подальшого використання. 
Недоліки: 
-	висока складність інтеграції з іншими програмними системами;
-	потреба в постійній підтримці та оновленнях. 
Обидві програмні системи орієнтовані на підприємства та компанії, що цікавляться забезпеченням безпеки та ефективності на робочому місці шляхом контролю за рівнем алкоголю в крові працівників. Оцінюючи попит на подібні рішення, можна вважати цей ринок перспективним, оскільки більше компаній шукають способи забезпечити безпеку та продуктивність на робочому місці. 
Щодо моделі монетизації, програмні системи можуть використовувати різні підходи, такі як оплата за повну функціональність або оплата за обсяг користування. Прибуток буде генеруватися через продаж ліцензій на використання системи або послуги підтримки та консультацій.


1.1.2 Бізнес цілі та критерії успіху


BO-1: Підвищення ефективності контролю рівня алкоголю на робочому місці. 
SC-1: Зниження кількості випадків сп'яніння працівників на робочому місці на 30% протягом перших 6 місяців впровадження системи. 
BO-2: Забезпечення безпеки працівників та уникнення аварійних ситуацій. 
SC-2: Зменшення кількості нещасних випадків через сп'яніння на робочому місці на 25% протягом першого року використання системи. 
BO-3: Збереження репутації компанії та підвищення довіри споживачів. 
SC-3: Збільшення рівня задоволеності клієнтів на 15% за період перших 9 місяців з впровадженням системи. 
BO-4: Оптимізація робочих процесів та підвищення ефективності використання ресурсів. 
SC-4: Зменшення часу на реагування на сп'яніння працівника до 15 хвилин з моменту виявлення. 
BO-5: Підвищення морального клімату та зниження конфліктних ситуацій на робочому місці. 
SC-5: Збільшення кількості позитивних відгуків співробітників про безпеку та комфортність умов праці на 20% після перших 3 місяців впровадження системи. 


1.1.3 Потреби клієнтів або ринку


Програмна система для контролю рівня алкоголю в крові працівників на робочому місці є ключовим інструментом для забезпечення безпеки та ефективності в робочому середовищі. Основні потреби та вимоги до цієї системи включають:
-	точність та надійність результатів: система повинна забезпечувати точні та надійні вимірювання рівня алкоголю в крові, що є важливим аспектом для здоров'я і безпеки працівників;
-	швидкість виконання тестів: важливо, щоб система оперативно проводила тести і надавала результати в реальному часі, щоб можна було негайно реагувати на будь-які виявлені відхилення від норми;
-	зручний інтерфейс для користувачів: користувачам, які проходять тестування, потрібен інтуїтивно зрозумілий і простий у використанні інтерфейс, що дозволяє легко взаємодіяти з системою;
-	конфіденційність і безпека даних: всі дані про результати тестів мають бути захищені від несанкціонованого доступу і зберігатися в безпечному середовищі;
-	моніторинг: система повинна забезпечувати можливість моніторингу рівня алкоголю в реальному часі для подальшого аналізу і вдосконалення безпеки на виробництві.


1.1.4 Бізнес-ризики


Конкуренція на ринку: 
-	ризик: поява конкуруючих продуктів може ускладнити впровадження системи та зменшити зацікавленість користувачів;
-	заходи зниження ризику: ретельний аналіз ринку та розробка унікальних функціональних можливостей для вирізнення серед конкурентів. 
Технічні проблеми та збої в системі: 
-	ризик: технічні неполадки можуть призвести до недоступності системи та порушити її продуктивність;
-	заходи зниження ризику: регулярне обслуговування системи, тестування перед впровадженням та швидка реакція на виявлені проблеми.

Залежність від сторонніх постачальників: 
-	ризик: Залежність від сторонніх постачальників програмного забезпечення чи обладнання може спричинити затримки у розробці або недостатню якість продукту; 
-	заходи зниження ризику: укладення договорів з гарантіями якості та надійності постачання, а також пошук альтернативних постачальників.


1.2 Концепція рішення
1.2.1 Окреслення концепції


	Проєкт спрямований на поліпшення безпеки та продуктивності в робочих умовах. Продукт є важливим кроком у вдосконаленні управління ризиками, пов'язаними з вживанням алкоголю під час роботи.
Основною метою системи є забезпечення безпеки та здоров'я працівників, запобігання небезпечних ситуацій, які можуть виникнути внаслідок алкогольного сп'яніння на робочому місці. Шляхом впровадження цієї системи є прагнення до створення робочого середовища, де кожен працівник може бути впевненим у своєму благополуччі та безпеці.
Переваги програмної системи включають можливість постійного моніторингу рівня алкоголю в крові працівників, автоматичне сповіщення у випадку виявлення сп'яніння, а також створення детальних звітів та аналізів для керівництва компанії. Це допоможе уникнути потенційних небезпек та ризиків, пов'язаних з вживанням алкоголю на робочому місці, і підвищить ефективність роботи колективу.
Розробка цієї програмної системи допоможе підвищити безпеку та здоров'я працівників, зменшити ризик аварій та травм, а також сприятиме підвищенню продуктивності на робочому місці. Це важливий крок у створенні безпечних та здорових умов праці, які забезпечать успішну діяльність підприємства та зростання його конкурентоспроможності.


1.2.2	Головна функціональність


MF-1. Автоматичне вимірювання рівня алкоголю в крові працівників:
функція передбачає використання спеціалізованого обладнання для точного та автоматичного вимірювання рівня алкоголю в крові працівників без необхідності у ручному втручанні. Система повинна бути надійною та точною, забезпечуючи консистентні результати.
MF-2. Ідентифікація працівника перед проведенням тестування:
перед кожним тестуванням система має перевіряти та ідентифікувати працівника, щоб забезпечити, що результати тестування правильно призначаються конкретній особі. Це може включати використання різних методів ідентифікації, таких як біометричні дані, картки доступу чи інші ідентифікатори.
MF-3. Збереження та аналіз результатів тестування для кожного працівника: система повинна забезпечувати збереження усіх результатів тестування в базі даних, де кожен результат зберігається разом із відповідною інформацією про працівника. 
MF-4. Інтеграція з існуючою системою контролю доступу для обмеження доступу працівників з високим рівнем алкоголю до робочих зон:
функція передбачає взаємодію програмної системи з існуючими системами контролю доступу, щоб автоматично обмежувати доступ працівників з виявленим сп'янінням до певних робочих зон або ресурсів.
MF-5. Надання сповіщень адміністраторам у разі виявлення працівників з високим рівнем алкоголю: система повинна автоматично сповіщати відповідальних адміністраторів чи керівників про виявлення працівників з високим рівнем алкоголю, щоб негайно приймати заходи безпеки та діяти відповідно до установлених правил компанії.
MF-6. Можливість встановлення індивідуальних порогових значень для кожного працівника відповідно до правил компанії або законодавства:
функція дозволяє налаштовувати індивідуальні порогові значення рівня алкоголю для кожного підприємства, враховуючи особливості компанійних політик чи законодавчих вимог.
MF-7. Забезпечення конфіденційності та безпеки збереження даних про результати тестування: функція передбачає використання високих стандартів безпеки даних для забезпечення конфіденційності та цілісності результатів тестування працівників.
MF-8. Підтримка інтерфейсу для адміністраторів для перегляду та управління результатами тестування: система повинна надавати зручний інтерфейс для адміністраторів, де вони можуть переглядати, аналізувати та управляти результатами тестування працівників, включаючи доступ до детальної інформації та можливість приймати рішення.
MF-9. Можливість звітування та статистичного аналізу результатів тестування для виявлення тенденцій та покращення ефективності системи:
функція дозволяє створювати звіти та проводити статистичний аналіз результатів тестування для ідентифікації тенденцій, виявлення можливих проблем та покращення ефективності системи контролю рівня алкоголю.
MF-10. Інтеграція з системами управління персоналом для внесення даних про результати тестування до загального персонального файлу працівника: функція передбачає автоматичну інтеграцію з існуючими системами управління персоналом для безперервного оновлення інформації про результати тестування в персональних файлах працівників компанії.


1.2.3 Припущення і залежності


П-1: Робоче середовище включає доступ до електричної мережі для живлення пристроїв для вимірювання рівня алкоголю. 
П-2: Працівники зобов'язані дотримуватися процедур тестування та ідентифікації, щоб забезпечити точність та надійність результатів. 
П-3: Адміністраторам та керівництву компанії надається доступ до результатів тестування для прийняття відповідних управлінських рішень. 
П-4: Працівники будуть користуватися системою з відповідальністю та дотриманням внутрішніх правил компанії щодо алкогольного споживання на робочому місці. 
П-5: Адміністратори системи повинні мати достатні повноваження та доступ до ресурсів для забезпечення безперебійної роботи системи та реагування на будь-які проблеми.
П-6: Вимірювальні пристрої та програмне забезпечення системи мають бути належно налаштовані та регулярно перевірятися для забезпечення точності результатів тестування. 
З-1: Ефективне функціонування системи базується на співпраці з підприємствами, які прагнуть забезпечити безпеку та продуктивність працівного середовища. 
З-2: Встановлення та підтримка системи можуть вимагати спеціалізованих знань та навичок, або можуть бути виконані фахівцями з інформаційних технологій.
З-3: Успішне впровадження системи передбачає сприятливе регулювання щодо використання та зберігання особистої інформації працівників. 
З-4: Наявність необхідного обладнання та програмного забезпечення для проведення тестування та збереження результатів у відповідності з вимогами компанії та законодавства. 
З-5: Співпраця та підтримка від керівництва компанії для встановлення необхідних процедур та стандартів щодо використання системи та інтерпретації результатів тестування.


1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


	Серверна (Back-End) частина: 
-	реєстрація та авторизація користувачів: створення можливості реєстрації та входу користувачів з різними ролями та правами доступу;
-	моніторинг рівня алкоголю в крові: розробка функціоналу для автоматичного вимірювання та аналізу рівня алкоголю в крові працівників на робочому місці;
-	збереження та аналіз результатів тестування: реалізація можливості зберігання та аналізу результатів тестування для кожного працівника;
-	інтеграція з системою контролю доступу: створення інтеграції з існуючою системою контролю доступу для обмеження доступу працівників з високим рівнем алкоголю до робочих зон;
-	сповіщення адміністраторам: впровадження функціоналу, що надає можливість отримання сповіщень адміністраторами у разі виявлення працівників з високим рівнем алкоголю;
-	налаштування індивідуальних порогових значень: реалізація можливості налаштування індивідуальних порогових значень для кожного працівника згідно з правилами компанії або законодавства;
-	захист даних та безпека: створення засобів захисту даних та резервне копіювання для забезпечення конфіденційності та безпеки збереження інформації про результати тестування. 
Front-End частина: 
-	веб-інтерфейс для користувачів: розробка зручного веб-інтерфейсу для взаємодії з системою через веб-браузер;
-	використання  JWT Bearer-токенів для ідентифікації користувача;
-	можливість перегляду списку компаній, редагування їх, створення нових, можливість редагування наявних компаній; можливість перегляду локацій, їх редагування, створення нових локацій, редагування наявних; можливість взаємодіяти з користувачами системи: редагування, видалення, перегляд, створення; перегляд та видалення результатів тестування, перегляд сповіщень;
-	локалізація та інтернаціоналізація: підтримка різних мов, кодових таблиць та іншої інформації для забезпечення комфортного користування в різних регіонах. 
Мобільний додаток: 
-	авторизація та реєстрація користувачів: можливість авторизації користувачів з мобільних пристроїв; 
-	перегляд результатів тестування: після проходження тестування на рівень алкоголю користувач може переглянути свої результати в мобільному додатку, що дозволяє швидко та зручно оцінити своє становище;
-	нагадування про тестування: додаток може надсилати користувачам нагадування про необхідність пройти тестування на рівень алкоголю у визначений час або інтервал; 
-	інтеграція з IoT-пристроями: додаток може підтримувати зчитування даних з IoT-пристроїв та сенсорів, які використовуються для вимірювання рівня алкоголю в крові працівників; 
-	керування обліковим записом: користувачі можуть змінювати свої особисті дані, налаштовувати параметри нагадувань та отримувати доступ до інших функцій управління обліковим записом; 
-	відстеження історії тестувань: додаток забезпечує можливість перегляду історії тестувань, що дозволяє користувачам вести облік своєї активності та змін у рівні алкоголю впродовж часу.
IoT Частина: 
-	збір даних з IoT-пристроїв: розробка функціоналу для збору даних з IoT-пристроїв на робочому місці;
-	відправка даних на відповідні ендпоінти серверної частини;
-	використання  JWT Bearer-токенів для ідентифікації користувача.


1.3.2 Рамки наступних випусків


Front-end частина: 
-	покращений інтерфейс користувача: розробка нового інтерфейсу з урахуванням зручності використання для користувачів усіх рівнів технічної грамотності; 
-	розширення функціоналу сповіщень: впровадження персоналізованих сповіщень, які враховують індивідуальні потреби та побажання користувачів; 
-	модуль аналітики та звітності: розробка інструментів для глибшого аналізу даних та генерації звітів для кращого розуміння трендів і паттернів у рівні алкоголю на робочому місці.
Мобільний додаток: 
-	розширення можливостей мобільного додатка: додавання нових функцій, таких як можливість використання штучного інтелекту для прогнозування рівня алкоголю або інтеграція зі здоров'ям та фітнес-додатками для комплексного моніторингу стану користувача; 
-	удосконалення взаємодії з користувачем: впровадження додаткових можливостей спілкування з користувачем, таких як онлайн-чат з фахівцями з питань здоров'я або можливість планування особистих цілей щодо споживання алкоголю. 
IoT частина: 
-	розширення функціональності сенсорів: впровадження нових сенсорів та вдосконалення існуючих для вимірювання додаткових параметрів, які можуть впливати на рівень алкоголю, таких як рівень глюкози в крові або дихальний обмін;
-	вдосконалення алгоритмів аналізу даних: розробка та впровадження більш точних та ефективних алгоритмів аналізу даних для більш надійного та швидкого виявлення змін у рівні алкоголю в крові.
Back-end частина: 
-	удосконалення системи керування користувачами: впровадження можливостей управління групами користувачів та надання різноманітних рівнів доступу для кожного користувача в системі;
-	розробка системи аналізу та передбачення: створення модулів для аналізу даних та використання методів машинного навчання для передбачення змін у рівні алкоголю та вчасного надання рекомендацій користувачам;
-	покращення адміністративних можливостей: розширення інструментів адміністратора для керування функціональністю системи, включаючи можливість налаштування сповіщень, створення звітів та моніторингу стану системи в реальному часі;
-	забезпечення високої доступності та швидкості роботи: оптимізація системи для забезпечення стабільної роботи навіть при великому обсязі даних та високому навантаженні на сервер.


1.3.3 Обмеження та вийнятки


Залежність від доступу до електроенергії: 
-	обмеження: для надійної роботи системи контролю рівня алкоголю в крові працівників необхідно постійне електропостачання;
-	виняток: у випадку відсутності електропостачання система може використовувати акумулятор або генератор для забезпечення роботи в непередбачуваних ситуаціях. 
Збій Інтернет-з'єднання: 
-	обмеження: втрата Інтернет-з'єднання може призвести до втрати зв'язку з сервером і неможливості отримати оновлення даних;
-	виняток: система може перейти в автономний режим роботи і зберегти дані локально до відновлення зв'язку. 
Обмежені ресурси сервера: 
-	обмеження: недостатні обчислювальні потужності сервера можуть вплинути на швидкість реакції системи; 
-	виняток: система може бути масштабована для оптимальної роботи навіть при великому обсязі даних. 
Технічні збої: 
-	обмеження: непередбачені технічні проблеми можуть призвести до відмови системи у роботі; 
-	виняток: система має вбудовані механізми резервного копіювання та відновлення, що дозволять швидко вирішити проблеми і продовжити роботу.


1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


	Профілі зацікавлених сторін проєкту містяться у таблиці 1.
	
Таблиця 1 – Профілі зацікавлених сторін проєкту 

Зацікавлена сторона	Головна цінність	Основні інтереси	Ставлення	Обмеження
Керівництво компанії	Забезпечення безпеки працівників та відповідність нормативним вимогам	Підвищення продуктивності, зменшення праці, моніторинг і керування	Позитивне	Фінансові обмеження
Адміністратори системи	Ефективне управління та надійність системи	Забезпечення безперебійної роботи та швидкого виявлення та виправлення помилок	Позитивне	Обмежені технічні ресурси
Кінець табл. 1.1
Медичний персонал	Точність та надійність даних про рівень алкоголю в крові працівників	Забезпечення достовірних результатів тестування та підтримання здоров'я працівників	Нейтральне	Обмеження доступу до конфіденційних даних
ІТ-спеціалісти	Функціональність та безпека програмної системи	Розробка та підтримка системи згідно з вимогами безпеки та ефективності	Позитивне	Обмежені терміни впровадження
Працівники компанії	Забезпечення конфіденційності та приватності особистих даних	Забезпечення конфіденційності особистих даних та зручного доступу до системи	Позитивне	Обмежені можливості доступу
Клієнти компанії	Гарантія безпеки та надійності продукції	Впевненість у тому, що продукція виготовляється безпечно та з стандартів якості	Нейтральне	Обмеженість доступу до системи


1.4.2 Пріоритети проєкту 


	Пріоритети проєкту містяться у таблиці 2.

	Таблиця 2 – Пріоритети проєкту

Показники	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
План робіт	10.06.2024		Від графіку на 
1-2 місяці
Функціональність			90% функціональності повинно бути реалізовано у першому релізі
Якість			У першому релізі повинен пройти 100% тестів
Персонал		Максимальний розмір команди: 1 розробник та адміністратор 	
Ціна		120000 грн	Допустиме перевищення на 15%


1.4.3 Робоче середовище


Система буде використовуватися в глобальному середовищі, оскільки користувачі можуть бути розподілені географічно та знаходитися в різних часових поясах. Це означає, що доступ до системи буде потрібен цілодобово із різних частин світу. Користувачам у різних місцях потрібен неперервний доступ до системи, оскільки це може бути критичним для роботи їхнього бізнесу. 
Дані, які генеруються та використовуються системою, можуть бути розподілені на різних серверах та пристроях. Це означає, що потрібно забезпечити ефективну передачу даних та збереження їх цілісності, навіть якщо вони знаходяться в різних частинах світу. 
З метою забезпечення надійності та доступності системи, важливо мати максимально низький час відповіді для доступу до даних, особливо для критичних операцій. Також потрібно передбачити можливість автономної роботи системи у випадку відмови основних серверів. 
Щодо безпеки доступу та захисту даних, необхідно встановити ефективні механізми автентифікації та авторизації користувачів, а також шифрування та захист від несанкціонованого доступу до даних. Крім того, слід враховувати вимоги щодо локалізації та інтернаціоналізації, забезпечуючи можливість використання системи на різних мовах та мірах ваги. 
На серверній стороні системи буде використовуватися мова програмування Golang з фреймворком Gin. Це дозволить створити потужний та швидкодіючий бекенд для обробки великого обсягу даних та запитів від користувачів. Система аутентифікації буде реалізована на основі JWT (JSON Web Tokens), що забезпечить безпеку та автентифікацію користувачів під час взаємодії з сервером. У якості СУБД буде використано MySQL.
Для розробки клієнтської частини системи буде використано фреймворк Vue.js. Він дозволить створити динамічні та інтерактивні інтерфейси для користувачів з мінімальними затратами часу та ресурсів. 
Для емуляції вимірювання даних алкогольного сп'яніння буде використано мову програмування C++. Це дозволить створити ефективну та точну систему для аналізу та вимірювання рівня алкоголю в організмі. 
Для розробки мобільного додатку буде використано мову програмування Kotlin. Це дозволить створити швидкий, ефективний та зручний додаток для користувачів. 
Загальна архітектура системи буде ретельно спланована та підібрана з метою забезпечення високої продуктивності, надійності та безпеки. Кожна складова системи буде оптимізована для виконання своїх функцій та взаємодії з іншими компонентами.


2 ПОСТАНОВКА ЗАДАЧІ


Згідно з попереднім аналізом предметної області, завданням курсової роботи було поставлено створення програмної системи для контролю рівня алкоголю в крові працівників на робочому місці.
База даних має включати в собі наступну інформацію про: користувачів, компанії, розташування, сповіщення, результати тестування, доступ до робітничої зони.
Робітник підприємства повинен мати такі можливості:
-	реєстрація та авторизація;
-	створення результатів тестування;
-	отримання результатів тестування;
-	отримання інформації про контроль доступу до робітничої зони.
Адміністратор повинен мати можливості:
-	реєстрація та авторизація;
-	перегляд, видалення, редагування, створення користувачів;
-	перегляд, видалення, редагування, створення компаній;
-	перегляд, видалення, редагування, створення локацій;
-	перегляд, створення, видалення сповіщень;
-	отримання результатів тестування, видалення;
-	створення резервної копії, відновлення, експорт даних, імпорт.
Програмна система також повинна забезпечувати локалізацію та інтернаціоналізацію, включаючи підтримку різних наборів символів, обчислення та форматування дати і часу, локальний та універсальний час, метричні одиниці вимірювання, англійську та американську системи мір.


3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
3.1 Побудова ER-діаграми


В результаті аналізу предметної області було визначено та розроблено основні сутності та відповідно зв’язки між ними. Результат було представлено у вигляді ER-діаграми (див. рис. 3.1).
Сутність «Користувач» містить інформацію про користувачів системи, пов’язана зв’язком «багато до одного» із сутністю «Компанія»,  також пов’язана зв’язком «один до багатьох» із сутностями «Сповіщення», «Результат тестування», «Контроль доступу до робітничої зони».
Сутність «Компанія» включає в себе інформацію про компанії, пов’язана зв’язком «один до багатьох» з сутностями «Адреси» та «Користувач».
Сутність «Сповіщення» зберігає інформацію про сповіщення користувача про рівень алкоголю, пов’язана з таблицею «Користувач».
Сутність «Адреси» зберігає інформацію про розташування компаній, пов’язана з сутністю «Компанія».
Сутність «Результат тестування» зберігає результати тестування певного користувача, пов’язана з сутністю «Користувач».
Сутність «Контроль до робітничої зони» містить інформацію про доступ користувача до робочої зони, пов’язана з сутністю «Користувач».


3.2 Побудова логічної моделі бази даних на основі ER-діаграми


Щоб побудувати логічну модель бази даних, необхідно спочатку визначити таблиці, які вона повинна містити. Тому базуємося на сутностях, визначених у діаграмі ER:
-	локація (Location);
-	компанія (Company);
-	користувач (User);
-	результати тестування (TestResult);
-	сповіщення (Notification);
-	контроль доступу до робітничої зони (AccessControl).
Створимо таблицю користувачів (User), яка буде в собі містити наступні атрибути: User_id (первинний ключ), Username, Email, Password, Role, Name, Surname, Patronymic, CompanyID (ключ для зв’язку типу багато до одного з таблицею Company), Sex.
Проведемо перевірку даної таблиці на відповідність нормалізації:
-	усі атрибути атомарні, тобто містять в собі тільки одне значення, а не сукупність;
-	дані не повторюються;
-	усі неключові атрибути мають залежність від первинного ключа.
Робимо висновок, що таблиця знаходиться в першій, другій, а отже, і в третій нормальних формах [1].
	Створимо таблицю компаній (Company), яка буде в собі містити наступні атрибути: Company_id (первинний ключ), Name, Description, LegalLimit, LocationID (ключ для зв’язку типу один до багатьох з таблицею Location).
Проведемо перевірку даної таблиці на відповідність нормалізації:
-	усі атрибути атомарні, тобто містять в собі тільки одне значення, а не сукупність;
-	дані не повторюються;
-	усі неключові атрибути мають залежність від первинного ключа.
Робимо висновок, що таблиця знаходиться в першій, другій, а отже, і в третій нормальних формах.
Створимо таблицю локацій (Location), яка буде в собі містити наступні атрибути:  Location_id (первинний ключ), Country, City, Adress, PostCode.
Проведемо перевірку даної таблиці на відповідність нормалізації:
-	усі атрибути атомарні, тобто містять в собі тільки одне значення, а не сукупність;
-	дані не повторюються;
-	усі неключові атрибути мають залежність від первинного ключа.
Робимо висновок, що таблиця знаходиться в першій, другій, а отже, і в третій нормальних формах.
Створимо таблицю результатів тестування (TestResult), яка буде в собі містити наступні атрибути: TestResult_id (первинний ключ), UserID (ключ для зв’язку типу багато до одного з таблицею User), TestTime, AlcoholLevel, IsDrunk, Description.
Проведемо перевірку даної таблиці на відповідність нормалізації:
-	усі атрибути атомарні, тобто містять в собі тільки одне значення, а не сукупність;
-	дані не повторюються;
-	усі неключові атрибути мають залежність від первинного ключа.
Робимо висновок, що таблиця знаходиться в першій, другій, а отже, і в третій нормальних формах.
Створимо таблицю сповіщень (Notification), яка буде в собі містити наступні атрибути: Notification_id (первинний ключ), Message, SentTime, UserID (ключ для зв’язку типу багато до одного з таблицею User).
Проведемо перевірку даної таблиці на відповідність нормалізації:
-	усі атрибути атомарні, тобто містять в собі тільки одне значення, а не сукупність;
-	дані не повторюються;
-	усі неключові атрибути мають залежність від первинного ключа.
Робимо висновок, що таблиця знаходиться в першій, другій, а отже, і в третій нормальних формах.
Створимо таблицю контролю доступу до робітничої зони (AccessControl), яка буде в собі містити наступні атрибути: AccessControl_id (первинний ключ), UserID (ключ для зв’язку типу багато до одного з таблицею User), AccessTime, Access.
Проведемо перевірку даної таблиці на відповідність нормалізації:
-	усі атрибути атомарні, тобто містять в собі тільки одне значення, а не сукупність;
-	дані не повторюються;
-	усі неключові атрибути мають залежність від первинного ключа.
Робимо висновок, що таблиця знаходиться в першій, другій, а отже, і в третій нормальних формах.
Результатом проектування таблиць та зв’язків між ними була отримана логічна схема бази даних (див. рис. 3.2).


4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
4.1 Архітектура серверної частини


Програмна система передбачає два типи користувачів: адміністратор та працівник підприємства.
Основними потребами працівника підприємства є: 
-	перегляд результатів тестування; 
-	створення результатів тестування.
-	перегляд сповіщень
Основними потребами адміністратора є:
-	перегляд локацій, видалення локацій, редагування локацій, створення локацій;
-	перегляд результатів тестування, видалення результатів тестування;
-	перегляд сповіщень, видалення сповіщень;
-	перегляд компаній, видалення компаній, створення компаній, редагування компаній;
-	перегляд користувачів системи, редагування, видалення, створення нових користувачів.
-	робота з даними: експорт даних, резервна копія налаштувань та даних БД, відновлення резервної копії.
Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див. рис. 4.1).


Рисунок 4.1 – Діаграма прецедентів серверної частини

За допомогою діаграми прецедентів було визначено функціональні потреби різних типів користувачів та взаємодію з програмною системою. 
Для розробки серверної частини було обрано мову програмування Golang з використанням веб-фреймворку Gin. У якості бази даних використано MySQL [2], яка розвернута в контейнері Doker, доступ до якої здійснюється з серверної програми за допомогою SQL package in Go, що забезпечує зручний інтерфейс для взаємодії з базою даних. 
	На основі використаних технологій було розроблено діаграму розгортання (див. рис. 4.2).

 
Рисунок 4.2 – Діаграма розгортання серверної частини

Архітектура була побудована за принципом чистої архітектури (Clean Architecture), також було використано шари які включають в себе такі пакети, як сервіси (Services), репозиторії (Repositories), хендлери (Handlers). Кожен шар має свою відповідальність, і виклики йдуть з верхнього шару до нижнього. Обробники викликають сервіси, а сервіси в свою чергу викликають репозиторії.
Використано OpenApi (Postman) для тестування та огляду серверної частини, що дозволяє ефективно виконати такі дії. 
Для організації коду було використано підхід CQRS (Command Query Responsibility Segregation), який розділяє команди, що змінюють стан системи, від запитів, що повертають дані про цей стан. Такий підхід допомагає чітко структурувати код та забезпечує легке розширення функціональності системи, полегшуючи подальший розвиток і підтримку проекту [3].
Взаємозв'язки між пакетами та їх структуру можна побачити на діаграмі пакетів (див. рис. 4.3).

 
Рисунок 4.3 – Діаграма пакетів

Таким чином було визначено технології та архітектуру серверної частини програмної системи.
Програмний код серверної частини міститься в Додатку А.


4.2 Архітектура IoT частини


Розроблена IoT частина взаємодіє з одним типом користувачів, тобто працівниками виробництва. Смарт девайс матиме можливість вимірювати дані пов’язані з алкогольним сп’янінням працівника.
Для початку роботи з IoT частиною потрібно здійснити вхід в систему за допомогою консолі, тобто ввести аутентифікаційні дані, назву облікового запису та пароль. Після входу в систему користувач матиме змогу вимірювати показник алкогольного сп’яніння. 
IoT пристрій працює в одному потоці та виконує такий ряд функцій:
a) функція authenticateUser:
1) аутентифікація користувача, надсилаючи POST запит з логіном і паролем до сервера;
2)	отримання відповіді від сервера, отримання токену аутентифікації, якщо вхід в систему пройшов успішно.
б) функція simulateDataAndSend:
1) генерація випадкових даних рівня алкоголю в крові, поточний час та опис тестування;
2) формування JSON об'єкта з даними;
3) виклик функції sendPostRequest для відправки даних на сервер.
в) функція sendPostRequest:
1) виконує відправку POST запиту з даними JSON на вказаний URL;
2) використання libcurl для виконання HTTP запиту;
3) обробка відпові від сервера.
	Взаємодію користувача з системою представлено на діаграмі прецедентів (див. рис. 4.4).

 
Рисунок 4.4 – діаграма прецедентів 


Для демонстрації роботи IoT частини було обрано мову програмування C++, що максимально наближено до апаратних вимог IoT пристроїв.
Для відображення інформації використовується командний інтерфейс (CLI) з використанням компілятора MSVC (Microsoft Visual C++), передача даних до серверної частини відбувається завдяки бібліотеці curl у форматі JSON. 
Використано стандартні бібліотеки та інструменти, такі як libcurl для виконання HTTP запитів та nlohmann/json для обробки JSON даних, що значно спрощує розробку та підтримку коду. Також такий підхід полегшує інтеграцію з існуючими системами та забезпечує можливість швидко реагувати на зміни вимог або умов експлуатації.
Взаємозв’язки між пакетами IoT частини відображено на діаграмі пакетів (див. рис. 4.5).

 
Рисунок 4.5 – Діаграма пакетів IoT частини


Програма IoT частини написана з мінімальним обсягом коду для оптимізації під обмежену потужність пристроїв та легкості переносу на реальні IoT пристрої.
Під час розробки цієї частини програмної системи була обрана клієнт-серверна архітектурна модель, що дозволяє досягти оптимального балансу між простотою реалізації та можливістю масштабування. Такий підхід забезпечує ефективну роботу системи навіть із зростанням її складності та дозволяє легко інтегрувати підтримку нових пристроїв без значних змін у внутрішньому коді.
Одним із головних аспектів нашого підходу є зменшення використання постійної пам'яті. Це покращує продуктивність системи та знижує вимоги до обладнання. У результаті система здатна функціонувати на різних пристроях з обмеженими ресурсами, забезпечуючи швидку обробку даних та стабільну роботу.		
Результатом вибору архітектурних	рішень є створення UML діаграми діяльності, яка відображає структуру та взаємодію компонентів системи (див. рис. 4.6).

 
Рисунок 4.6 – Діаграма діяльності IoT частини


Результатом розробки IoT частини програмної системи є застосунок для вбудованих систем, який може бути використаний на різних пристроях. Користувачу необхідно вказати логін та пароль для аутентифікації в системі та продовження роботи з нею. 
Після успішної ініціалізації програма створює один потік, який реалізовує в собі такі функції як авторизація, генерація даних та відправка даних на сервер. Під час взаємодії з серверною частиною програма отримує та надсилає дані на сервер використовуючи для цього відповідні кінцеві точки на стороні серверу.
	Програмна система продовжує вимірювати рівень алкогольного сп’яніння працівника та надсилати дані на сервер до тих пір, поки користувач не вийде із застосунку. 
Для відображення структури проекту була створена UML діаграма взаємодії (див. рис. 4.7).

 
Рисунок 4.7 – Діаграма взаємодії IoT застосунку

Програмний код IoT частини міститься в додатку Б.


4.3 Архітектура клієнтської частини


Програмна частина розрахована на один тип користувачів, а саме на адміністратора системи, який зможе керувати даними програмної системи.
Необхідним функціоналом адміністратора є: можливість перегляду списку компаній, редагування їх, створення нових, можливість редагування наявних компаній; можливість перегляду локацій, їх редагування, створення нових локацій, редагування наявних; можливість взаємодіяти з користувачами системи: редагування, видалення, перегляд, створення; перегляд та видалення результатів тестування, перегляд сповіщень. Окрім вищевказаних можливостей адміністратор може взаємодіяти з базою даних, а саме створювати резервні копії, завантажувати резервні копії, робити експорт даних. Взаємодію адміністратора з системою зображено на діаграмі прецедентів (див. рис. 4.7).
Продукт має підтримку локалізації, надає користувачу інтерфейс англійською та українською мовами.

 
Рисунок 4.7 – Діаграма прецедентів


Для реалізації клієнтської частини програмної системи було обрано мову програмування JavaScript, яка підтримується усіма сучасними веб-браузерами.
Було вирішено використовувати фреймворк Vue.js [4] для створення користувацького інтерфейсу, що дозволяє зручно генерувати HTML з даних, що зберігаються в JavaScript. У цьому проекті використовується стандартна структура проекту на Vue, яка включає всі необхідні інструменти для ефективної розробки.
Щоб реалізувати багатосторінкову навігацію на сайті, було використано Vue Router, який забезпечує динамічну маршрутизацію у браузері.
Для локалізації, використано бібліотеку i18next для ефективного впровадження багатомовного інтерфейсу та зручного перекладу текстів.
Було створено діаграму пакетів для візуалізації залежностей між різними частинами програмного забезпечення.
Взаємозв’язки між пакетами клієнтської частини відображено на діаграмі пакетів (див. рис. 4.8).

 
Рисунок 4.8 – Діаграма пакетів


У процесі розробки програмного забезпечення використовувалася компонентна архітектура, що є стандартом для сучасних фреймворків для створення інтерфейсів. Залежності між компонентами зображені на діаграмі компонентів (див. рис. 4.9).

 
Рисунок 4.9 – Діаграма компонентів


Користування програмним забезпеченням починається з домашньої сторінки. З цієї сторінки користувач може перейти до сторінки входу в систему, створення облікових записів, перегляду та редагування даних, а також до сторінки створення резервних копій бази даних. На кожній сторінці є посилання для навігації та кнопки вибору мови інтерфейсу: англійської або української.
Для доступу до сторінок редагування даних та створення резервних копій користувач повинен пройти аутентифікацію та мати права адміністратора. Після введення своїх даних і відправлення запиту на сервер, браузер обробляє відповідь і встановлює Cookie, які будуть використовуватися для подальшої аутентифікації.
Для полегшення розуміння взаємодії користувачів з клієнтською частиною системи була створена діаграма взаємодії (див. рис. 4.10).

 	 
 Рисунок 4.10 – Діаграма взаємодії


Під час проектування системи були визначені ключові технології та архітектурні рішення, які будуть використовуватися на наступних етапах розробки.
Додаток В містить приклади коду клієнтської частини системи.


5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
5.1 Виклик і завантаження


Для запуску коду необхідно завантажити архів з кодом, розпакувати його. Зважаючи на те, що в програмному коді використовувалась СУБД MySQL потрібно завантажити останню версію з сайту розробника. 
Для забезпечення з’єднання застосунку з базою даних необхідно перейти в директорію «apz-pzpi-21-11-maiboroda-bohdan-task2» та змінити файл .env в якому міститься пароль бази даних, окрім цього необхідно змінити файл конфігурації та вказати там параметри підключення до бази даних, зробити це можна перейшовши в директорію «apz-pzpi-21-11-maiboroda-bohdan-task2\configs», змінивши при цьому файл config.yaml.
Для запуску серверної частини необхідно відкрити проєкт в середовищі розробки, рекомендовано використовувати Golang, далі відкрити термінал та перейти в директорію «apz-pzpi-21-11-maiboroda-bohdan-task2», написати команду run cmd/main.go, після чого почнеться компілювання та запуск програми.
Для роботи з IoT частиною необхідно встановити найновішу версію середовища розробки Microsoft Visual Studio, в ньому перейти в директорію  «apz-pzpi-21-11-maiboroda-bohdan-task3», відкрити файл Task3.sln після чого відбудеться процес підвантаження файлів проєкту. Використовуючи сполучення клавіш «Ctrl+F5» здійснюється запуск IoT частини.


5.2 Призначення і логічна структура


	Функції які може виконувати програмна система можна поділити на кілька модулів:
-	авторизація та реєстрація;
-	компанії;
-	локації;
-	результати тестування;
-	сповіщення;
-	користувачі системи;
-	контроль доступу до робітничих зон.
Модуль «Авторизація та реєстрація» містить у собі функцію для аутентифікації користувача, тобто вхід в систему та створення облікового запису. Реєстрація дозволяє внести клієнту свої дані до бази даних та отримувати доступ до них в подальшому. Адміністратор зможе зареєструватися в системі за допомогою спеціального ендпоінту.
Модуль «Компанії» має в собі функції для перегляду, додавання, редагування, видалення компаній.
Модуль «Локації» має в собі функції для перегляду, додавання, редагування, видалення Локацій.
Модуль «Результати тестування» несе в собі функціонал запису результатів вимірювання алкоголю в крові працівника виробництва, їх перегляд, адміністратор має можливість їх видаляти. 
Модуль «Сповіщення» призначений для надсилання та перегляду працівником виробництва сповіщень про перевищення рівню алкоголю або сповіщення про те, що показник алкоголю в крові знаходиться в межах норми.
Модуль «Користувачі» призначений для адміністраторів, в ньому вони зможуть переглядати список користувачів, редагувати їх, створювати та видаляти. 
Модуль «Доступ до робітничої зони» призначений для перегляду користувачами можливості доступу до робітничої, тобто перегляд часу коли користувач зможе отримати доступ до робітничої зони у разі його алкогольного сп’яніння.


5.3 Опис програмної реалізації


	При запуску клієнтської частини можна побачити головну сторінку, з якої можемо перейти до функціоналу реєстрації або авторизації для доступу до решти функцій. (див. рис. 5.1). Клієнтська частина розрахована лише для одного типу користувачів – адміністраторів.
Рисунок 5.1 – Головна сторінка сайту 

На цій сторінці ми можемо ввійти в систему або зареєструватись як адміністратор.

При вході в систему необхідно ввести аутентифікаційні дані користувача такі як логін та пароль (див. рис. 5.2).

 
Рисунок 5.2 – Сторінка авторизації


	При створенні нового облікового запису необхідно ввести такі дані як: юзернейм, електронну пошту, пароль, ім’я, прізвище, по батькові, вказати компанію та стать (див. рис. 5.3).

 
Рисунок 5.3 – Створення нового облікового запису адміністратора


	Після входу в систему адміністратор отримує доступ до управління компаніями, локаціями, користувачами, видаляти результати тестування, проглядати сповіщення, керувати даними шляхом створення резервних копій, відновлення бази даних за допомогою відновлення, робити експорт всіх таблиць у форматі EXEL.
	Розглянемо сторінку управління компаніями (див. рис. 5.4), адміністратор має можливість створювати, видаляти, редагувати та переглядати наявні компанії. 

 
Рисунок 5.4 – Управління компаніями


Розглянемо сторінку управління розташуваннями (див. рис. 5.5), адміністратор має можливість створювати, видаляти, редагувати та переглядати наявні локації.
 
Рисунок 5.5 – Сторінка керування розташуваннями

Також користувач має можливість управляти наявними користувачами в системі, створювати нових (див. рис. 5.6).

 
Рисунок 5.6 – Управління користувачами


Адміністратор має можливість переглядати результати всіх тестувань та видаляти їх (див. рис. 5.7). 

 
Рисунок 5.7 – Сторінка управління результатами тестування


	Окрім цього адміністратор може переглядати сповіщення про перевищення рівню алкоголю в крові або сповіщення про те, що цей рівень знаходиться в межах норми (див. рис. 5.7).

 
Рисунок 5.7 – Сторінка перегляду сповіщень
Адміністратор має можливість створення резервних копій, відновлення даних завдяки резервній копії, експорт даних у форматі EXEL (див. рис. 5.8).

 
Рисунок 5.8 – Сторінка управління базою даних та експорту даних


	При натисканні на кнопку створення резервної копії, відновлення або експорту відправляється запит до серверу, після чого браузер повідомляє про успішність операції (див. рис. 5.9).

 
Рисунок 5.9 – Результат створення резервної копії


Таким чином було розглянуто функціональні можливості програмної системи для контролю рівня алкоголю в крові працівників на робочому місці.


ВИСНОВОК


У ході виконання курсової роботи було розроблено комплексну програмну систему для контролю рівня алкоголю в крові працівників під час їхньої роботи. Основна мета проекту забезпечення безпеки та підвищення ефективності виробничих процесів була успішно досягнута завдяки створенню інтегрованої системи, яка дозволяє відслідковувати та контролювати рівень алкоголю у працівників.
Система, розроблена з використанням мови програмування Golang для серверної частини, забезпечує стабільність і безпеку обробки даних. Веб-інтерфейс на основі Vue.js робить користування програмою зручним і ефективним для відображення результатів моніторингу. За допомогою IoT програми, написаної на C++, вдалося створити рішення для збору даних про рівень алкоголю в реальному часі, що дозволяє точно визначати стан працівників та оперативно повідомляти адміністрацію у разі виявлення алкогольного сп'яніння.
Додатково система забезпечує зберігання даних тестування, що дозволяє виявляти тенденції та покращувати стратегії контролю. Це сприяє оптимізації процесів управління та швидкому реагуванню на можливі небезпечні ситуації.
Таким чином, створена програмна система не лише забезпечує безпеку на робочому місці, але й допомагає підприємствам підвищити ефективність і знизити ризики, пов'язані з недопустимим вживанням алкоголю під час роботи. Результати роботи мають важливе практичне значення та можуть бути успішно застосовані на різних підприємствах для підвищення безпеки та ефективності виробничих процесів.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Реляционные базы данных | Нормализация. URL: https://metanit.com/sql/tutorial/2.1.php (дата звернення: 24.04.2024).
2.	MySQL 8.0 Reference Manual. MySQL Documentation. URL: https://dev.mysql.com/doc/refman/8.0/en/ (дата звернення: 02.05.2024).
3.	Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley Professional Computing Series) / R. Helm та ін. Addison-Wesley Professional, 1995. 395 р. (дата звернення: 10.05.24).
4.	Vue.js - The Progressive JavaScript Framework | Vue.js URL: https://vuejs.org/ (дата звернення: 18.05.24).


ДОДАТОК А
Програмний код серверної частини
А.1 Код основного файлу для роботи сервера main.go


1 package main
2 
3 import (
4 	AlcoSafe "apz-pzpi-21-11-maiboroda-bohdan-task2"
5 	"apz-pzpi-21-11-maiboroda-bohdan-task2/pkg/handler"
6 	"apz-pzpi-21-11-maiboroda-bohdan-task2/pkg/repository"
7 	"apz-pzpi-21-11-maiboroda-bohdan-task2/pkg/service"
8 	"github.com/joho/godotenv"
9 	"github.com/sirupsen/logrus"
10 	"github.com/spf13/viper"
11 	"os"
12 )
13 
14 func main() {
15 	if err := initConfig(); err != nil {
16 		logrus.Fatalf("error initializing configs: %s", err.Error())
17 	}
18 
19 	if err := godotenv.Load(); err != nil {
20 		logrus.Fatalf("Error loading env variables: %s", err.Error())
21 	}
22 
23 	db, err := repository.NewMysqlDb(repository.Config{
24 		Host:     viper.GetString("db.host"),
25 		Port:     viper.GetString("db.port"),
26 		Username: viper.GetString("db.username"),
27 		Password: os.Getenv("DB_PASSWORD"),
28 		Dbname:   viper.GetString("db.dbname"),
29 	})
30 	if err != nil {
31 		logrus.Fatalf("Failed to initialize db %s", err.Error())
32 	}
33 
34 	repos := repository.NewRepository(db)
35 	services := service.NewService(repos)
36 	handlers := handler.NewHandler(services)
37 
38 	srv := new(AlcoSafe.Server)
39 
40 	if err := srv.Run(viper.GetString("port"), handlers.InitRoutes()); err != nil {
41 		logrus.Fatalf("error running server: %s", err.Error())
42 	}
43 }
44 
45 func initConfig() error {
46 	viper.AddConfigPath("configs")
47 	viper.SetConfigName("config")
48 	return viper.ReadInConfig()
49 }


А.2 Код адміністрації програмної системи admin_mysql.go


1 package repository
2 
3 import (
4 	AlcoSafe "apz-pzpi-21-11-maiboroda-bohdan-task2"
5 	"bytes"
6 	"database/sql"
7 	"errors"
8 	"fmt"
9 	"github.com/go-sql-driver/mysql"
10 	"github.com/jmoiron/sqlx"
11 	"github.com/sirupsen/logrus"
12 	"github.com/tealeg/xlsx"
13 	"io/ioutil"
14 	"log"
15 	"os"
16 	"os/exec"
17 	"strings"
18 )
19 
20 type AdminMysql struct {
21 	db *sqlx.DB
22 }
23 
24 func NewAdminMysql(db *sqlx.DB) *AdminMysql {
25 	return &AdminMysql{db: db}
26 }
27 
28 func (r *AdminMysql) GetUserByID(userID int) (AlcoSafe.User, error) {
29 	var user AlcoSafe.User
30 	query := fmt.Sprintf("SELECT UserID, Username, Email, Role, Name, Surname, Patronymic, Sex FROM User WHERE UserID=?")
31 	err := r.db.Get(&user, query, userID)
32 	if err != nil {
33 		log.Printf("Error fetching user by ID %d: %s", userID, err)
34 	}
35 	return user, err
36 }
37 
38 func (r *AdminMysql) CreateUser(user AlcoSafe.User) (int, error) {
39 	checkQuery := fmt.Sprintf("SELECT COUNT(*) FROM User WHERE email=? OR username=?")
40 	var count int
41 	err := r.db.Get(&count, checkQuery, user.Email, user.Username)
42 	if err != nil {
43 		return 0, err
44 	}
45 
46 	if count > 0 {
47 		return 0, fmt.Errorf("user with this email or username already exists")
48 	}
49 
50 	query := fmt.Sprintf("INSERT INTO User (Username, Email, Password, Role, Name, Surname, Patronymic, Sex) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)")
51 
52 	result, err := r.db.Exec(query, user.Username, user.Email, user.Password, user.Role, user.Name, user.Surname, user.Patronymic, user.Sex)
53 	if err != nil {
54 		mysqlErr, ok := err.(*mysql.MySQLError)
55 		if ok && mysqlErr.Number == 1062 {
56 			return 0, fmt.Errorf("user with this email or username already exists")
57 		}
58 		return 0, err
59 	}
60 
61 	id, err := result.LastInsertId()
62 	if err != nil {
63 		return 0, err
64 	}
65 
66 	return int(id), nil
67 }
68 func (r *AdminMysql) GetAllUsers() ([]AlcoSafe.User, error) {
69 	var users []AlcoSafe.User
70 	query := fmt.Sprintf("SELECT UserID, Username, Email, Role, Name, Surname, Patronymic, CompanyID, Sex FROM User")
71 	err := r.db.Select(&users, query)
72 	if err != nil {
73 		log.Printf("Error fetching all users: %s", err)
74 	}
75 	return users, err
76 }
77 func (r *AdminMysql) UpdateUser(UserID int, input AlcoSafe.UpdateUserInput, user AlcoSafe.User) error {
78 	existingUser, err := r.GetUserByID(UserID)
79 	if err != nil {
80 		return err
81 	}
82 
83 	if input.Email != nil {
84 		checkEmailQuery := "SELECT UserID FROM User WHERE Email=? AND UserID != ?"
85 		var otherUserID int
86 		err := r.db.Get(&otherUserID, checkEmailQuery, *input.Email, UserID)
87 		if err != nil && err != sql.ErrNoRows {
88 			return err
89 		}
90 		if otherUserID != 0 {
91 			return errors.New("user with this email already exists")
92 		}
93 
94 		existingUser.Email = *input.Email
95 	}
96 
97 	if input.Username != nil {
98 		checkUsernameQuery := "SELECT UserID FROM User WHERE Username=? AND UserID != ?"
99 		var otherUserID int
100 		err := r.db.Get(&otherUserID, checkUsernameQuery, *input.Username, UserID)
101 		if err != nil && err != sql.ErrNoRows {
102 			return err
103 		}
104 		if otherUserID != 0 {
105 			return errors.New("user with this username already exists")
106 		}
107 
108 		existingUser.Username = *input.Username
109 	}
110 
111 	if input.Role != nil {
112 		existingUser.Role = *input.Role
113 	}
114 
115 	if input.Name != nil {
116 		existingUser.Name = *input.Name
117 	}
118 
119 	if input.Surname != nil {
120 		existingUser.Surname = *input.Surname
121 	}
122 
123 	if input.Patronymic != nil {
124 		existingUser.Patronymic = *input.Patronymic
125 	}
126 
127 	if input.CompanyID != nil {
128 		existingUser.CompanyID = *input.CompanyID
129 	}
130 
131 	if input.Sex != nil {
132 		existingUser.Sex = *input.Sex
133 	}
134 
135 	query := fmt.Sprintf("UPDATE User SET Username=?, Email=?, Password=?, Role=?, Name=?, Surname=?, Patronymic=?, CompanyID=?, Sex=? WHERE UserID=?")
136 	_, err = r.db.Exec(query, existingUser.Username, existingUser.Email, existingUser.Password, existingUser.Role, existingUser.Name, existingUser.Surname, existingUser.Patronymic, existingUser.CompanyID, existingUser.Sex, UserID)
137 	if err != nil {
138 		return err
139 	}
140 
141 	return nil
142 }
143 func (r *AdminMysql) Delete(UserID int) error {
144 	query := fmt.Sprintf("DELETE FROM User WHERE UserID = ? ")
145 	_, err := r.db.Exec(query, UserID)
146 	return err
147 }
148 func (r *AdminMysql) BackupData(backupPath string) error {
149 	cmd := exec.Command(
150 		"docker",
151 		"exec",
152 		"alcosafe-db",
153 		"mysqldump",
154 		"-u",
155 		"root",
156 		"-pROOT",
157 		"mysql",
158 	)
159 
160 	outputFile, err := os.Create(backupPath)
161 	if err != nil {
162 		return fmt.Errorf("error creating backup file: %s", err)
163 	}
164 	defer outputFile.Close()
165 
166 	cmd.Stdout = outputFile
167 
168 	if err := cmd.Run(); err != nil {
169 		return fmt.Errorf("error running mysqldump: %s", err)
170 	}
171 
172 	return nil
173 }
174 func (r *AdminMysql) RestoreData(backupPath string) error {
175 	backupPath = "backup.sql"
176 
177 	containerBackupPath := "/var/lib/mysql/backup.sql"
178 	cmd := exec.Command(
179 		"docker",
180 		"cp",
181 		backupPath,
182 		"alcosafe-db:"+containerBackupPath,
183 	)
184 	if err := cmd.Run(); err != nil {
185 		logrus.Errorf("Failed to copy dump file to container: %s", err)
186 		return err
187 	}
188 
189 	dumpContent, err := ioutil.ReadFile(backupPath)
190 	if err != nil {
191 		logrus.Errorf("Failed to read dump file: %s", err)
192 		return err
193 	}
194 
195 	mysqlCmd := exec.Command(
196 		"docker",
197 		"exec",
198 		"-i",
199 		"alcosafe-db",
200 		"mysql",
201 		"-u",
202 		"root",
203 		"-pROOT",
204 		"mysql",
205 	)
206 
207 	mysqlCmd.Stdin = bytes.NewReader(dumpContent)
208 	mysqlCmd.Stdout = os.Stdout
209 	mysqlCmd.Stderr = os.Stderr
210 
211 	if err := mysqlCmd.Run(); err != nil {
212 		logrus.Errorf("Failed to restore data in container: %s", err)
213 		return err
214 	}
215 
216 	return nil
217 }
218 func (r *AdminMysql) ExportData(exportPath string) error {
219 	logger := logrus.New()
220 
221 	file := xlsx.NewFile()
222 
223 	tables := map[string]string{
224 		"User":          "SELECT * FROM User;",
225 		"AccessControl": "SELECT * FROM AccessControl;",
226 		"Notification":  "SELECT * FROM Notification;",
227 		"TestResult":    "SELECT * FROM TestResult;",
228 		"Company":       "SELECT * FROM Company;",
229 		"Location":      "SELECT * FROM Location;",
230 	}
231 
232 	for tableName, query := range tables {
233 		rows, err := r.db.Query(query)
234 		if err != nil {
235 			logger.Errorf("Error querying table %s: %s", tableName, err)
236 			return fmt.Errorf("error querying table %s: %w", tableName, err)
237 		}
238 		defer rows.Close()
239 
240 		columns, err := rows.Columns()
241 		if err != nil {
242 			logger.Errorf("Error fetching columns for table %s: %s", tableName, err)
243 			return fmt.Errorf("error fetching columns for table %s: %w", tableName, err)
244 		}
245 
246 		sheet, err := file.AddSheet(tableName)
247 		if err != nil {
248 			logger.Errorf("Error adding sheet %s: %s", tableName, err)
249 			return fmt.Errorf("error adding sheet %s: %w", tableName, err)
250 		}
251 
252 		headerRow := sheet.AddRow()
253 		for _, column := range columns {
254 			cell := headerRow.AddCell()
255 			cell.Value = column
256 		}
257 
258 		for rows.Next() {
259 			rowData := make([]sql.NullString, len(columns))
260 			valuePointers := make([]interface{}, len(columns))
261 			for i := range rowData {
262 				valuePointers[i] = &rowData[i]
263 			}
264 
265 			err := rows.Scan(valuePointers...)
266 			if err != nil {
267 				logger.Errorf("Error scanning rows for table %s: %s", tableName, err)
268 				return fmt.Errorf("error scanning rows for table %s: %w", tableName, err)
269 			}
270 
271 			row := sheet.AddRow()
272 			for _, value := range rowData {
273 				cell := row.AddCell()
274 				if value.Valid {
275 					cell.Value = value.String
276 				} else {
277 					cell.Value = "NULL"
278 				}
279 			}
280 		}
281 	}
282 
283 	err := file.Save(exportPath)
284 	if err != nil {
285 		logger.Errorf("Error saving Excel file: %s", err)
286 		return fmt.Errorf("error saving Excel file: %w", err)
287 	}
288 
289 	return nil
290 }
291 
292 func (r *AdminMysql) ImportData(importPath string) error {
293 	file, err := xlsx.OpenFile(importPath)
294 	if err != nil {
295 		logrus.Errorf("Error opening Excel file: %s", err)
296 		return fmt.Errorf("error opening Excel file: %w", err)
297 	}
298 
299 	for _, sheet := range file.Sheets {
300 		tableName := sheet.Name
301 
302 		rows := sheet.Rows
303 		if len(rows) < 2 {
304 			continue
305 		}
306 
307 		columns := make([]string, len(rows[0].Cells))
308 		for i, cell := range rows[0].Cells {
309 			columns[i] = cell.String()
310 		}
311 
312 		query := fmt.Sprintf("INSERT IGNORE INTO %s (%s) VALUES ", tableName, strings.Join(columns, ",")) // or use INSERT ... ON DUPLICATE KEY UPDATE
313 
314 		var valueStrings []string
315 		var valueArgs []interface{}
316 
317 		for _, row := range rows[1:] {
318 			var values []interface{}
319 
320 			for _, cell := range row.Cells {
321 				values = append(values, cell.Value)
322 			}
323 
324 			placeholders := make([]string, len(columns))
325 			for i := range placeholders {
326 				placeholders[i] = "?"
327 			}
328 
329 			valueStrings = append(valueStrings, "("+strings.Join(placeholders, ",")+")")
330 			valueArgs = append(valueArgs, values...)
331 		}
332 
333 		query += strings.Join(valueStrings, ",")
334 		_, err := r.db.Exec(query, valueArgs...)
335 		if err != nil {
336 			logrus.Errorf("Error inserting data into table %s: %s", tableName, err)
337 			return fmt.Errorf("error inserting data into table %s: %w", tableName, err)
338 		}
339 	}
340 
341 	return nil
342 }


А.3 Програмний код з функціями пов’язаними з вимірюванням алкоголю в крові


1 package repository
2 
3 import (
4 	AlcoSafe "apz-pzpi-21-11-maiboroda-bohdan-task2"
5 	"github.com/jmoiron/sqlx"
6 	"log"
7 	"time"
8 )
9 
10 type TestResultMysql struct {
11 	db *sqlx.DB
12 }
13 
14 func NewTestResultMysql(db *sqlx.DB) *TestResultMysql {
15 	return &TestResultMysql{db: db}
16 }
17 
18 func (r *TestResultMysql) Create(userID int, testresult AlcoSafe.TestResult) (int, error) {
19 	var companyID int
20 	err := r.db.QueryRow("SELECT CompanyID FROM User WHERE UserID = ?", userID).Scan(&companyID)
21 	if err != nil {
22 		return 0, err
23 	}
24 
25 	var legalLimit float64
26 	err = r.db.QueryRow("SELECT LegalLimit FROM Company WHERE CompanyID = ?", companyID).Scan(&legalLimit)
27 	if err != nil {
28 		return 0, err
29 	}
30 
31 	isDrunk := testresult.AlcoholLevel > legalLimit
32 
33 	query := "INSERT INTO TestResult (UserID, TestTime, AlcoholLevel, IsDrunk, Description) VALUES (?, NOW(), ?, ?, ?)"
34 	res, err := r.db.Exec(query, userID, testresult.AlcoholLevel, isDrunk, testresult.Description)
35 	if err != nil {
36 		return 0, err
37 	}
38 
39 	id, err := res.LastInsertId()
40 	if err != nil {
41 		return 0, err
42 	}
43 
44 	notificationMessage := "Your alcohol level is within the legal limit."
45 	if isDrunk {
46 		notificationMessage = "Your alcohol level exceeds the legal limit!"
47 	}
48 
49 	notification := AlcoSafe.Notification{
50 		UserID:   userID,
51 		Message:  notificationMessage,
52 		SentTime: time.Now().Format("2006-01-02 15:04:05"),
53 	}
54 
55 	_, err = r.CreateNotification(notification)
56 	if err != nil {
57 		return 0, err
58 	}
59 
60 	access := "Allowed"
61 	accessTime := time.Now().Format("2006-01-02 15:04:05")
62 	if isDrunk {
63 		access = "Rejected"
64 		soberingHours := testresult.AlcoholLevel / 0.015
65 		accessTime = time.Now().Add(time.Duration(soberingHours) * time.Hour).Format("2006-01-02 15:04:05")
66 	}
67 
68 	accessControl := AlcoSafe.AccessControl{
69 		UserID:     userID,
70 		AccessTime: accessTime,
71 		Access:     access,
72 	}
73 	_, err = r.CreateAccessControl(accessControl)
74 	if err != nil {
75 		return 0, err
76 	}
77 
78 	return int(id), nil
79 }
80 
81 func (r *TestResultMysql) CreateNotification(notification AlcoSafe.Notification) (int, error) {
82 	query := "INSERT INTO Notification (Message, SentTime, UserID) VALUES (?, ?, ?)"
83 	res, err := r.db.Exec(query, notification.Message, time.Now(), notification.UserID)
84 	if err != nil {
85 		return 0, err
86 	}
87 
88 	id, err := res.LastInsertId()
89 	if err != nil {
90 		return 0, err
91 	}
92 
93 	return int(id), nil
94 }
95 
96 func (r *TestResultMysql) CreateAccessControl(accessControl AlcoSafe.AccessControl) (int, error) {
97 	query := "INSERT INTO AccessControl (UserID, AccessTime, Access) VALUES (?, ?, ?)"
98 	res, err := r.db.Exec(query, accessControl.UserID, accessControl.AccessTime, accessControl.Access)
99 	if err != nil {
100 		return 0, err
101 	}
102 
103 	id, err := res.LastInsertId()
104 	if err != nil {
105 		return 0, err
106 	}
107 
108 	return int(id), nil
109 }
110 
111 func (r *TestResultMysql) GetUserTestResult(userID int) ([]AlcoSafe.TestResult, error) {
112 	var testresult []AlcoSafe.TestResult
113 	query := "SELECT * FROM TestResult WHERE UserID=?"
114 	err := r.db.Select(&testresult, query, userID)
115 	return testresult, err
116 }
117 
118 func (r *TestResultMysql) Delete(testResultID int) error {
119 	query := "DELETE FROM TestResult WHERE TestID = ?"
120 	_, err := r.db.Exec(query, testResultID)
121 	return err
122 }
123 
124 func (r *TestResultMysql) GetAll() ([]AlcoSafe.TestResult, error) {
125 	var testResults []AlcoSafe.TestResult
126 	query := "SELECT tr.TestID, tr.UserID, tr.TestTime, tr.AlcoholLevel, tr.IsDrunk, tr.Description, u.Username " +
127 		"FROM TestResult tr " +
128 		"LEFT JOIN User u ON tr.UserID = u.UserID"
129 	err := r.db.Select(&testResults, query)
130 	if err != nil {
131 		log.Printf("Error fetching test results: %s", err)
132 		return nil, err
133 	}
134 	return testResults, nil
135 }
136 
137 func (r *TestResultMysql) GetByID(testResultID int) (AlcoSafe.TestResult, error) {
138 	var testResult AlcoSafe.TestResult
139 	query := "SELECT * FROM TestResult WHERE TestResultID = ?"
140 	err := r.db.Get(&testResultID, query, testResultID)
141 	if err != nil {
142 		return testResult, err
143 	}
144 	return testResult, nil
145 }


А.4 Програмний код панелі адміністратора 


1 package repository
2 
3 import (
4 	AlcoSafe "apz-pzpi-21-11-maiboroda-bohdan-task2"
5 	"bytes"
6 	"database/sql"
7 	"errors"
8 	"fmt"
9 	"github.com/go-sql-driver/mysql"
10 	"github.com/jmoiron/sqlx"
11 	"github.com/sirupsen/logrus"
12 	"github.com/tealeg/xlsx"
13 	"io/ioutil"
14 	"log"
15 	"os"
16 	"os/exec"
17 	"strings"
18 )
19 
20 type AdminMysql struct {
21 	db *sqlx.DB
22 }
23 
24 func NewAdminMysql(db *sqlx.DB) *AdminMysql {
25 	return &AdminMysql{db: db}
26 }
27 
28 func (r *AdminMysql) GetUserByID(userID int) (AlcoSafe.User, error) {
29 	var user AlcoSafe.User
30 	query := fmt.Sprintf("SELECT UserID, Username, Email, Role, Name, Surname, Patronymic, Sex FROM User WHERE UserID=?")
31 	err := r.db.Get(&user, query, userID)
32 	if err != nil {
33 		log.Printf("Error fetching user by ID %d: %s", userID, err)
34 	}
35 	return user, err
36 }
37 
38 func (r *AdminMysql) CreateUser(user AlcoSafe.User) (int, error) {
39 	checkQuery := fmt.Sprintf("SELECT COUNT(*) FROM User WHERE email=? OR username=?")
40 	var count int
41 	err := r.db.Get(&count, checkQuery, user.Email, user.Username)
42 	if err != nil {
43 		return 0, err
44 	}
45 
46 	if count > 0 {
47 		return 0, fmt.Errorf("user with this email or username already exists")
48 	}
49 
50 	query := fmt.Sprintf("INSERT INTO User (Username, Email, Password, Role, Name, Surname, Patronymic, CompanyID, Sex) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)")
51 
52 	result, err := r.db.Exec(query, user.Username, user.Email, user.Password, user.Role, user.Name, user.Surname, user.Patronymic, user.CompanyID, user.Sex)
53 	if err != nil {
54 		mysqlErr, ok := err.(*mysql.MySQLError)
55 		if ok && mysqlErr.Number == 1062 {
56 			return 0, fmt.Errorf("user with this email or username already exists")
57 		}
58 		return 0, err
59 	}
60 
61 	id, err := result.LastInsertId()
62 	if err != nil {
63 		return 0, err
64 	}
65 
66 	return int(id), nil
67 }
68 func (r *AdminMysql) GetAllUsers() ([]AlcoSafe.User, error) {
69 	var users []AlcoSafe.User
70 	query := fmt.Sprintf("SELECT UserID, Username, Email, Role, Name, Surname, Patronymic, CompanyID, Sex FROM User")
71 	err := r.db.Select(&users, query)
72 	if err != nil {
73 		log.Printf("Error fetching all users: %s", err)
74 	}
75 	return users, err
76 }
77 func (r *AdminMysql) UpdateUser(UserID int, input AlcoSafe.UpdateUserInput, user AlcoSafe.User) error {
78 	existingUser, err := r.GetUserByID(UserID)
79 	if err != nil {
80 		return err
81 	}
82 
83 	if input.Email != nil {
84 		checkEmailQuery := "SELECT UserID FROM User WHERE Email=? AND UserID != ?"
85 		var otherUserID int
86 		err := r.db.Get(&otherUserID, checkEmailQuery, *input.Email, UserID)
87 		if err != nil && err != sql.ErrNoRows {
88 			return err
89 		}
90 		if otherUserID != 0 {
91 			return errors.New("user with this email already exists")
92 		}
93 
94 		existingUser.Email = *input.Email
95 	}
96 	if input.Password != nil {
97 		existingUser.Password = *input.Password
98 	}
99 	if input.Username != nil {
100 		checkUsernameQuery := "SELECT UserID FROM User WHERE Username=? AND UserID != ?"
101 		var otherUserID int
102 		err := r.db.Get(&otherUserID, checkUsernameQuery, *input.Username, UserID)
103 		if err != nil && err != sql.ErrNoRows {
104 			return err
105 		}
106 		if otherUserID != 0 {
107 			return errors.New("user with this username already exists")
108 		}
109 
110 		existingUser.Username = *input.Username
111 	}
112 
113 	if input.Role != nil {
114 		existingUser.Role = *input.Role
115 	}
116 
117 	if input.Name != nil {
118 		existingUser.Name = *input.Name
119 	}
120 
121 	if input.Surname != nil {
122 		existingUser.Surname = *input.Surname
123 	}
124 
125 	if input.Patronymic != nil {
126 		existingUser.Patronymic = *input.Patronymic
127 	}
128 
129 	if input.CompanyID != nil {
130 		existingUser.CompanyID = input.CompanyID
131 	}
132 
133 	if input.Sex != nil {
134 		existingUser.Sex = *input.Sex
135 	}
136 
137 	query := fmt.Sprintf("UPDATE User SET Username=?, Email=?, Password=?, Role=?, Name=?, Surname=?, Patronymic=?, CompanyID=?, Sex=? WHERE UserID=?")
138 	_, err = r.db.Exec(query, existingUser.Username, existingUser.Email, existingUser.Password, existingUser.Role, existingUser.Name, existingUser.Surname, existingUser.Patronymic, existingUser.CompanyID, existingUser.Sex, UserID)
139 	if err != nil {
140 		return err
141 	}
142 
143 	return nil
144 }
145 func (r *AdminMysql) Delete(UserID int) error {
146 	query := fmt.Sprintf("DELETE FROM User WHERE UserID = ? ")
147 	_, err := r.db.Exec(query, UserID)
148 	return err
149 }
150 func (r *AdminMysql) BackupData(backupPath string) error {
151 	cmd := exec.Command(
152 		"docker",
153 		"exec",
154 		"alcosafe-db",
155 		"mysqldump",
156 		"-u",
157 		"root",
158 		"-pROOT",
159 		"mysql",
160 	)
161 
162 	outputFile, err := os.Create(backupPath)
163 	if err != nil {
164 		return fmt.Errorf("error creating backup file: %s", err)
165 	}
166 	defer outputFile.Close()
167 
168 	cmd.Stdout = outputFile
169 
170 	if err := cmd.Run(); err != nil {
171 		return fmt.Errorf("error running mysqldump: %s", err)
172 	}
173 
174 	return nil
175 }
176 func (r *AdminMysql) RestoreData(backupPath string) error {
177 	backupPath = "backup.sql"
178 
179 	containerBackupPath := "/var/lib/mysql/backup.sql"
180 	cmd := exec.Command(
181 		"docker",
182 		"cp",
183 		backupPath,
184 		"alcosafe-db:"+containerBackupPath,
185 	)
186 	if err := cmd.Run(); err != nil {
187 		logrus.Errorf("Failed to copy dump file to container: %s", err)
188 		return err
189 	}
190 
191 	dumpContent, err := ioutil.ReadFile(backupPath)
192 	if err != nil {
193 		logrus.Errorf("Failed to read dump file: %s", err)
194 		return err
195 	}
196 
197 	mysqlCmd := exec.Command(
198 		"docker",
199 		"exec",
200 		"-i",
201 		"alcosafe-db",
202 		"mysql",
203 		"-u",
204 		"root",
205 		"-pROOT",
206 		"mysql",
207 	)
208 
209 	mysqlCmd.Stdin = bytes.NewReader(dumpContent)
210 	mysqlCmd.Stdout = os.Stdout
211 	mysqlCmd.Stderr = os.Stderr
212 
213 	if err := mysqlCmd.Run(); err != nil {
214 		logrus.Errorf("Failed to restore data in container: %s", err)
215 		return err
216 	}
217 
218 	return nil
219 }
220 func (r *AdminMysql) ExportData(exportPath string) error {
221 	logger := logrus.New()
222 
223 	file := xlsx.NewFile()
224 
225 	tables := map[string]string{
226 		"User":          "SELECT * FROM User;",
227 		"AccessControl": "SELECT * FROM AccessControl;",
228 		"Notification":  "SELECT * FROM Notification;",
229 		"TestResult":    "SELECT * FROM TestResult;",
230 		"Company":       "SELECT * FROM Company;",
231 		"Location":      "SELECT * FROM Location;",
232 	}
233 
234 	for tableName, query := range tables {
235 		rows, err := r.db.Query(query)
236 		if err != nil {
237 			logger.Errorf("Error querying table %s: %s", tableName, err)
238 			return fmt.Errorf("error querying table %s: %w", tableName, err)
239 		}
240 		defer rows.Close()
241 
242 		columns, err := rows.Columns()
243 		if err != nil {
244 			logger.Errorf("Error fetching columns for table %s: %s", tableName, err)
245 			return fmt.Errorf("error fetching columns for table %s: %w", tableName, err)
246 		}
247 
248 		sheet, err := file.AddSheet(tableName)
249 		if err != nil {
250 			logger.Errorf("Error adding sheet %s: %s", tableName, err)
251 			return fmt.Errorf("error adding sheet %s: %w", tableName, err)
252 		}
253 
254 		headerRow := sheet.AddRow()
255 		for _, column := range columns {
256 			cell := headerRow.AddCell()
257 			cell.Value = column
258 		}
259 
260 		for rows.Next() {
261 			rowData := make([]sql.NullString, len(columns))
262 			valuePointers := make([]interface{}, len(columns))
263 			for i := range rowData {
264 				valuePointers[i] = &rowData[i]
265 			}
266 
267 			err := rows.Scan(valuePointers...)
268 			if err != nil {
269 				logger.Errorf("Error scanning rows for table %s: %s", tableName, err)
270 				return fmt.Errorf("error scanning rows for table %s: %w", tableName, err)
271 			}
272 
273 			row := sheet.AddRow()
274 			for _, value := range rowData {
275 				cell := row.AddCell()
276 				if value.Valid {
277 					cell.Value = value.String
278 				} else {
279 					cell.Value = "NULL"
280 				}
281 			}
282 		}
283 	}
284 
285 	err := file.Save(exportPath)
286 	if err != nil {
287 		logger.Errorf("Error saving Excel file: %s", err)
288 		return fmt.Errorf("error saving Excel file: %w", err)
289 	}
290 
291 	return nil
292 }
293 
294 func (r *AdminMysql) ImportData(importPath string) error {
295 	file, err := xlsx.OpenFile(importPath)
296 	if err != nil {
297 		logrus.Errorf("Error opening Excel file: %s", err)
298 		return fmt.Errorf("error opening Excel file: %w", err)
299 	}
300 
301 	for _, sheet := range file.Sheets {
302 		tableName := sheet.Name
303 
304 		rows := sheet.Rows
305 		if len(rows) < 2 {
306 			continue
307 		}
308 
309 		columns := make([]string, len(rows[0].Cells))
310 		for i, cell := range rows[0].Cells {
311 			columns[i] = cell.String()
312 		}
313 
314 		query := fmt.Sprintf("INSERT IGNORE INTO %s (%s) VALUES ", tableName, strings.Join(columns, ",")) // or use INSERT ... ON DUPLICATE KEY UPDATE
315 
316 		var valueStrings []string
317 		var valueArgs []interface{}
318 
319 		for _, row := range rows[1:] {
320 			var values []interface{}
321 
322 			for _, cell := range row.Cells {
323 				values = append(values, cell.Value)
324 			}
325 
326 			placeholders := make([]string, len(columns))
327 			for i := range placeholders {
328 				placeholders[i] = "?"
329 			}
330 
331 			valueStrings = append(valueStrings, "("+strings.Join(placeholders, ",")+")")
332 			valueArgs = append(valueArgs, values...)
333 		}
334 
335 		query += strings.Join(valueStrings, ",")
336 		_, err := r.db.Exec(query, valueArgs...)
337 		if err != nil {
338 			logrus.Errorf("Error inserting data into table %s: %s", tableName, err)
339 			return fmt.Errorf("error inserting data into table %s: %w", tableName, err)
340 		}
341 	}
342 
343 	return nil
344 }


ДОДАТОК Б
Програмний код ІоТ частини


1 #include <iostream>
2 #include <curl/curl.h>
3 #include <string>
4 #include <chrono>
5 #include <random>
6 #include <ctime>
7 #include "nlohmann/json.hpp"
8 #include <conio.h>
9 
10 using namespace std;
11 using json = nlohmann::json;
12 
13 size_t write_callback(void* contents, size_t size, size_t nmemb, std::string* response) {
14     size_t realsize = size * nmemb;
15     response->append((char*)contents, realsize);
16     return realsize;
17 }
18 
19 std::string getCurrentTime() {
20     auto now = std::chrono::system_clock::now();
21     auto nowTime = std::chrono::system_clock::to_time_t(now);
22     std::tm gmTimeInfo;
23     gmtime_s(&gmTimeInfo, &nowTime);
24 
25     char buffer[80];
26     std::strftime(buffer, 80, "%Y-%m-%d %H:%M:%S", &gmTimeInfo);
27     return std::string(buffer);
28 }
29 
30 void sendPostRequest(const std::string& url, const std::string& jsonData, const std::string& authToken) {
31     CURL* curl;
32     CURLcode res;
33 
34     curl_global_init(CURL_GLOBAL_ALL);
35     curl = curl_easy_init();
36     if (curl) {
37         struct curl_slist* headers = NULL;
38         headers = curl_slist_append(headers, ("Authorization: Bearer " + authToken).c_str());
39         headers = curl_slist_append(headers, "Content-Type: application/json");
40 
41         curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
42         curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
43         curl_easy_setopt(curl, CURLOPT_POSTFIELDS, jsonData.c_str());
44 
45         std::string response_string;
46         curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
47         curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_string);
48 
49         res = curl_easy_perform(curl);
50         if (res != CURLE_OK)
51             std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << std::endl;
52 
53         curl_easy_cleanup(curl);
54         curl_slist_free_all(headers);
55     }
56     curl_global_cleanup();
57 }
58 
59 std::string authenticateUser(const std::string& url, const std::string& username, const std::string& password) {
60     CURL* curl;
61     CURLcode res;
62     std::string token;
63 
64     curl_global_init(CURL_GLOBAL_ALL);
65     curl = curl_easy_init();
66     if (curl) {
67         json loginData = {
68             {"username", username},
69             {"password", password}
70         };
71         std::string jsonData = loginData.dump();
72 
73         curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
74         curl_easy_setopt(curl, CURLOPT_POSTFIELDS, jsonData.c_str());
75 
76         std::string response_string;
77         curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
78         curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_string);
79 
80         res = curl_easy_perform(curl);
81         if (res == CURLE_OK) {
82             json responseJson = json::parse(response_string);
83             if (responseJson.find("token") != responseJson.end()) {
84                 token = responseJson["token"].get<std::string>();
85             }
86             else {
87                 std::cerr << "Error: Token not found in response." << std::endl;
88             }
89         }
90         else {
91             std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << std::endl;
92         }
93 
94         curl_easy_cleanup(curl);
95     }
96     curl_global_cleanup();
97 
98     return token;
99 }
100 
101 void simulateDataAndSend(const std::string& authToken) {
102     std::string currentTime = getCurrentTime();
103     std::random_device rd;
104     std::mt19937 gen(rd());
105 
106     std::uniform_real_distribution<double> alcoholLevelDist(0.0, 0.5);
107     double alcoholLevel = alcoholLevelDist(gen);
108 
109     std::string description = "Alcotest";
110 
111     json testResultData = {
112         {"UserID", 13},
113         {"TestTime", currentTime},
114         {"AlcoholLevel", alcoholLevel},
115         {"Description", description}
116     };
117 
118     std::string jsonData = testResultData.dump();
119 
120     std::cout << "\n";
121     std::cout << "Test Result Data:\n" << jsonData << std::endl;
122     std::cout << "\n";
123 
124     std::string endpoint = "http://localhost:8000/api/user/13/testresults";
125 
126     sendPostRequest(endpoint, jsonData, authToken);
127 }
128 
129 int main() {
130     std::string username;
131     std::string password;
132     cout << "Enter username: ";
133     cin >> username;
134     cout << "Enter password: ";
135     cin >> password;
136     std::string authUrl = "http://localhost:8000/auth/login";
137 
138     std::string authToken = authenticateUser(authUrl, username, password);
139 
140     if (!authToken.empty()) {
141         std::cout << "Authentication successful. Token obtained." << std::endl;
142 
143         bool stopSending = false;
144 
145         while (!stopSending) {
146             simulateDataAndSend(authToken);
147             Sleep(5000); 
148 
149             if (_kbhit()) {
150                 char key = _getch();
151                 if (key == 27) { 
152                     stopSending = true;
153                     std::cout << "\nSending stopped by user.\n";
154                 }
155             }
156         }
157     }
158     else {
159         std::cerr << "Authentication failed. Unable to obtain token." << std::endl;
160     }
161 
162     return 0;
163 }


ДОДАТОК В 
Програмний код клієнтської частини
В.1 Програмний код комунікації з серверною частиною


1 import axios from 'axios';
2 
3 const apiClient = axios.create({
4     baseURL: 'http://localhost:8000',
5     headers: {
6         'Content-Type': 'application/json',
7     },
8     withCredentials: true,
9 });
10 
11 apiClient.interceptors.request.use(config => {
12     const token = localStorage.getItem('token');
13     console.log('Intercepting request, token:', token);
14     if (token) {
15         config.headers.Authorization = `Bearer ${token}`;
16     }
17     console.log('Config headers:', config.headers);
18     return config;
19 }, error => {
20     return Promise.reject(error);
21 });
22 
23 apiClient.interceptors.response.use(response => {
24     console.log('Response headers:', response.headers);
25     return response;
26 }, error => {
27     if (error.response) {
28         console.error('Response error:', error.response);
29     } else {
30         console.error('Error without response:', error);
31     }
32     return Promise.reject(error);
33 });
34 export default {
35     // Auth endpoints
36     register(user) {
37         return apiClient.post('/auth/register', user);
38     },
39     registerAdmin(admin) {
40         return apiClient.post('/auth/registerAdmin', admin);
41     },
42     login(credentials) {
43         return apiClient.post('/auth/login', credentials);
44     },
45     logout(credentials){
46         return apiClient.post('/auth/logout', credentials);
47     },
48     // User endpoints
49     getUserTestResults(userID) {
50         return apiClient.get(`/api/user/${userID}/testresults`);
51     },
52     createUserTestResult(userID, testResult) {
53         return apiClient.post(`/api/user/${userID}/testresults`, testResult);
54     },
55     getUserNotifications(userID) {
56         return apiClient.get(`/api/user/${userID}/notifications`);
57     },
58     getUserAccessControls(userID) {
59         return apiClient.get(`/api/user/${userID}/accesscontrols`);
60     },
61 
62     // Admin endpoints
63     getCompanies() {
64         return apiClient.get('/api/admin/companies');
65     },
66     getCompanyByID(companyID) {
67         return apiClient.get(`/api/admin/companies/${companyID}`);
68     },
69     createCompany(company) {
70         return apiClient.post('/api/admin/companies', company);
71     },
72     updateCompany(companyID, company) {
73         return apiClient.put(`/api/admin/companies/${companyID}`, company);
74     },
75     deleteCompany(companyID) {
76         return apiClient.delete(`/api/admin/companies/${companyID}`);
77     },
78 
79     getLocations() {
80         return apiClient.get('/api/admin/locations');
81     },
82     getLocationByID(locationID) {
83         return apiClient.get(`/api/admin/locations/${locationID}`);
84     },
85     createLocation(location) {
86         return apiClient.post('/api/admin/locations', location);
87     },
88     updateLocation(locationID, location) {
89         return apiClient.put(`/api/admin/locations/${locationID}`, location);
90     },
91     deleteLocation(locationID) {
92         return apiClient.delete(`/api/admin/locations/${locationID}`);
93     },
94 
95     getUsers() {
96         return apiClient.get('/api/admin/users/');
97     },
98     createUser(user) {
99         return apiClient.post('/api/admin/users/', user);
100     },
101     getUserByID(userID) {
102         return apiClient.get(`/api/admin/users/${userID}`);
103     },
104     updateUser(userID, user) {
105         return apiClient.put(`/api/admin/users/${userID}`, user);
106     },
107     deleteUser(userID) {
108         return apiClient.delete(`/api/admin/users/${userID}`);
109     },
110 
111     getTestResults() {
112         return apiClient.get('/api/admin/testresults');
113     },
114     getTestResultByID(testID) {
115         return apiClient.get(`/api/admin/testresults/${testID}`);
116     },
117     deleteTestResult(testID) {
118         return apiClient.delete(`/api/admin/testresults/${testID}`);
119     },
120 
121     getAllNotifications() {
122         return apiClient.get('/api/admin/notifications');
123     },
124     getNotificationByID(notificationID) {
125         return apiClient.get(`/api/admin/notifications/${notificationID}`);
126     },
127     createNotification(notification) {
128         return apiClient.post('/api/admin/notifications', notification);
129     },
130     deleteNotification(notificationID) {
131         return apiClient.delete(`/api/admin/notifications/${notificationID}`);
132     },
133 
134     // Data management endpoints
135     backupData() {
136         return apiClient.post('/api/admin/data/backup');
137     },
138     restoreData() {
139         return apiClient.post('/api/admin/data/restore');
140     },
141     exportData() {
142         return apiClient.get('/api/admin/data/export');
143     },
144     importData(data) {
145         return apiClient.post('/api/admin/data/import', data);
146     },
147 };


В.2 Програмний код шляхів клієнтської частини router.js


1 import { createRouter, createWebHistory } from 'vue-router';
2 import store from '../store';
3 import HomePage from '../views/HomePage.vue';
4 import UserDashboard from '../views/UserDashboard.vue';
5 import AdminDashboard from '../views/AdminDashboard.vue';
6 import UserLogin from '../components/Auth/UserLogin.vue';
7 import UserRegister from '../components/Auth/UserRegister.vue';
8 import AdminRegister from '../components/Auth/AdminRegister.vue';
9 import CompaniesManagement from '../components/Admin/CompaniesManagement.vue';
10 import LocationsManagement from '../components/Admin/LocationsManagement.vue';
11 import UsersManagement from '../components/Admin/UsersManagement.vue';
12 import AdminTestResults from '../components/Admin/TestResults.vue';
13 import AdminNotifications from '../components/Admin/Notifications.vue';
14 import DataManagement from '../components/Admin/DataManagement.vue';
15 import UserTestResults from '../components/User/TestResults.vue';
16 import UserNotifications from '../components/User/Notifications.vue';
17 import UserAccessControl from '../components/User/AccessControl.vue';
18 
19 const routes = [
20     {
21         path: '/',
22         name: 'HomePage',
23         component: HomePage,
24         meta: { requiresGuest: true }
25     },
26     {
27         path: '/login',
28         name: 'UserLogin',
29         component: UserLogin,
30         meta: { requiresGuest: true }
31     },
32     {
33         path: '/register',
34         name: 'UserRegister',
35         component: UserRegister,
36         meta: { requiresGuest: true }
37     },
38     {
39         path: '/register-admin',
40         name: 'AdminRegister',
41         component: AdminRegister,
42         meta: { requiresGuest: true }
43     },
44     {
45         path: '/user-dashboard',
46         name: 'UserDashboard',
47         component: UserDashboard,
48         meta: { requiresAuth: true, requiresRole: 'User' },
49         children: [
50             {
51                 path: 'test-results',
52                 name: 'UserTestResults',
53                 component: UserTestResults,
54                 props: true
55             },
56             {
57                 path: 'notifications',
58                 name: 'UserNotifications',
59                 component: UserNotifications
60             },
61             {
62                 path: 'access-controls',
63                 name: 'UserAccessControls',
64                 component: UserAccessControl
65             }
66         ]
67     },
68     {
69         path: '/admin-dashboard',
70         name: 'AdminDashboard',
71         component: AdminDashboard,
72         meta: { requiresAuth: true, requiresRole: 'Admin' },
73         children: [
74             {
75                 path: 'companies',
76                 name: 'CompaniesManagement',
77                 component: CompaniesManagement
78             },
79             {
80                 path: 'locations',
81                 name: 'LocationsManagement',
82                 component: LocationsManagement
83             },
84             {
85                 path: 'users',
86                 name: 'UsersManagement',
87                 component: UsersManagement
88             },
89             {
90                 path: 'test-results',
91                 name: 'AdminTestResults',
92                 component: AdminTestResults
93             },
94             {
95                 path: 'notifications',
96                 name: 'AdminNotifications',
97                 component: AdminNotifications
98             },
99             {
100                 path: 'data-management',
101                 name: 'DataManagement',
102                 component: DataManagement
103             }
104         ]
105     }
106 ];
107 
108 const router = createRouter({
109     history: createWebHistory(),
110     routes
111 });
112 
113 router.beforeEach(async (to, from, next) => {
114     const isLoggedIn = store.getters.isLoggedIn;
115 
116     if (to.matched.some(record => record.meta.requiresAuth)) {
117         if (!isLoggedIn) {
118             next('/login');
119         } else {
120             try {
121                 const token = localStorage.getItem('token');
122                 const payload = parseJwt(token);
123                 const userRole = payload.role;
124 
125                 if (to.meta.requiresRole && to.meta.requiresRole !== userRole) {
126                     if (userRole === 'Admin' && to.path !== '/admin-dashboard') {
127                         next('/admin-dashboard');
128                     } else if (userRole === 'User' && to.path !== '/user-dashboard') {
129                         next('/user-dashboard');
130                     } else {
131                         next();
132                     }
133                 } else {
134                     next();
135                 }
136             } catch (error) {
137                 console.error('Error decoding token:', error);
138                 next('/login'); // Redirect to login page on error
139             }
140         }
141     } else if (to.matched.some(record => record.meta.requiresGuest)) {
142         if (isLoggedIn) {
143             next();
144         } else {
145             next();
146         }
147     } else {
148         next();
149     }
150 });
151 
152 function parseJwt(token) {
153     try {
154         return JSON.parse(atob(token.split('.')[1]));
155     } catch (e) {
156         return null;
157     }
158 }
159 
160 export default router;


ДОДАТОК Г
Результат перевірки на плагіат 


Рисунок Г.1 – Результат перевірки на плагіат


ДОДАТОК Ґ
Посилання на відеозапис з тестуванням системи


Посилання на відеозапис з проведеним функціональним тестуванням системи: https://youtu.be/g2Pzqjn2N_Q
